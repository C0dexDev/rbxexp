-- Gui to Lua
-- Version: 3.2

-- Instances:

local SL = Instance.new("ScreenGui")
local MainFrame = Instance.new("Frame")
local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
local UICorner = Instance.new("UICorner")
local Title = Instance.new("TextLabel")
local Container = Instance.new("ScrollingFrame")
local UIListLayout = Instance.new("UIListLayout")
local KillButton = Instance.new("TextButton")
local UICorner_2 = Instance.new("UICorner")
local Selected = Instance.new("TextLabel")
local Template = Instance.new("Frame")
local InnerFrame = Instance.new("Frame")
local UICorner_3 = Instance.new("UICorner")
local TextButton = Instance.new("TextButton")
local UICorner_4 = Instance.new("UICorner")
local PlayerName = Instance.new("TextLabel")
local GodButton = Instance.new("TextButton")
local UICorner_5 = Instance.new("UICorner")
local TPButton = Instance.new("TextButton")
local UICorner_6 = Instance.new("UICorner")

--Properties:

SL.Name = "SL"
SL.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
SL.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
SL.ResetOnSpawn = false

MainFrame.Name = "MainFrame"
MainFrame.Parent = SL
MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
MainFrame.BackgroundColor3 = Color3.fromRGB(76, 76, 76)
MainFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
MainFrame.BorderSizePixel = 0
MainFrame.Position = UDim2.new(0.906692564, 0, 0.517628193, 0)
MainFrame.Size = UDim2.new(0.192827001, 0, 0.352764428, 0)

UIAspectRatioConstraint.Parent = MainFrame
UIAspectRatioConstraint.AspectRatio = 0.800

UICorner.Parent = MainFrame

Title.Name = "Title"
Title.Parent = MainFrame
Title.AnchorPoint = Vector2.new(0.5, 0.5)
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1.000
Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
Title.BorderSizePixel = 0
Title.Position = UDim2.new(0.500002623, 0, 0.0777777582, 0)
Title.Size = UDim2.new(0.999994099, 0, 0.100000001, 0)
Title.Font = Enum.Font.SourceSansBold
Title.Text = "DEATH NOTE"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextScaled = true
Title.TextSize = 14.000
Title.TextWrapped = true

Container.Name = "Container"
Container.Parent = MainFrame
Container.Active = true
Container.AnchorPoint = Vector2.new(0.5, 0.5)
Container.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Container.BackgroundTransparency = 1.000
Container.BorderColor3 = Color3.fromRGB(0, 0, 0)
Container.BorderSizePixel = 0
Container.Position = UDim2.new(0.5, 0, 0.428278804, 0)
Container.Size = UDim2.new(1, 0, 0.545445979, 0)
Container.CanvasSize = UDim2.new(0, 0, 0, 0)
Container.ScrollBarThickness = 5
Container.AutomaticCanvasSize = Enum.AutomaticSize.Y

UIListLayout.Parent = Container
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder

KillButton.Name = "KillButton"
KillButton.Parent = MainFrame
KillButton.AnchorPoint = Vector2.new(0.5, 0.5)
KillButton.BackgroundColor3 = Color3.fromRGB(89, 255, 0)
KillButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
KillButton.BorderSizePixel = 0
KillButton.Position = UDim2.new(0.245156884, 0, 0.899216413, 0)
KillButton.Size = UDim2.new(0.426567137, 0, 0.1277778, 0)
KillButton.Font = Enum.Font.SourceSansBold
KillButton.Text = "KILL"
KillButton.TextColor3 = Color3.fromRGB(255, 255, 255)
KillButton.TextScaled = true
KillButton.TextSize = 14.000
KillButton.TextWrapped = true

UICorner_2.Parent = KillButton

Selected.Name = "Selected"
Selected.Parent = MainFrame
Selected.AnchorPoint = Vector2.new(0.5, 0.5)
Selected.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Selected.BackgroundTransparency = 1.000
Selected.BorderColor3 = Color3.fromRGB(0, 0, 0)
Selected.BorderSizePixel = 0
Selected.Position = UDim2.new(0.499999225, 0, 0.751773775, 0)
Selected.Size = UDim2.new(0.999997735, 0, 0.101544306, 0)
Selected.Font = Enum.Font.SourceSans
Selected.Text = "No player selected"
Selected.TextColor3 = Color3.fromRGB(255, 255, 255)
Selected.TextScaled = true
Selected.TextSize = 14.000
Selected.TextWrapped = true

Template.Name = "Template"
Template.Parent = MainFrame
Template.AnchorPoint = Vector2.new(0.5, 0.5)
Template.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Template.BackgroundTransparency = 1.000
Template.BorderColor3 = Color3.fromRGB(0, 0, 0)
Template.BorderSizePixel = 0
Template.Position = UDim2.new(0.5, 0, 0.148712516, 0)
Template.Size = UDim2.new(1, 0, 0.297425032, 0)
Template.Visible = false

InnerFrame.Name = "InnerFrame"
InnerFrame.Parent = Template
InnerFrame.AnchorPoint = Vector2.new(0.5, 0.5)
InnerFrame.BackgroundColor3 = Color3.fromRGB(54, 54, 54)
InnerFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
InnerFrame.BorderSizePixel = 0
InnerFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
InnerFrame.Size = UDim2.new(0.961111128, 0, 0.949999869, 0)

UICorner_3.Parent = InnerFrame

TextButton.Parent = InnerFrame
TextButton.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextButton.BackgroundTransparency = 1.000
TextButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextButton.BorderSizePixel = 0
TextButton.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton.Size = UDim2.new(1, 0, 1, 0)
TextButton.Font = Enum.Font.SourceSans
TextButton.Text = ""
TextButton.TextColor3 = Color3.fromRGB(0, 0, 0)
TextButton.TextSize = 14.000

UICorner_4.Parent = TextButton

PlayerName.Name = "PlayerName"
PlayerName.Parent = InnerFrame
PlayerName.AnchorPoint = Vector2.new(0.5, 0.5)
PlayerName.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
PlayerName.BackgroundTransparency = 1.000
PlayerName.BorderColor3 = Color3.fromRGB(0, 0, 0)
PlayerName.BorderSizePixel = 0
PlayerName.Position = UDim2.new(0.5, 0, 0.49999994, 0)
PlayerName.Size = UDim2.new(1, 0, 0.764186919, 0)
PlayerName.Font = Enum.Font.Arial
PlayerName.Text = "C0dexDev"
PlayerName.TextColor3 = Color3.fromRGB(255, 255, 255)
PlayerName.TextScaled = true
PlayerName.TextSize = 14.000
PlayerName.TextWrapped = true

GodButton.Name = "GodButton"
GodButton.Parent = MainFrame
GodButton.AnchorPoint = Vector2.new(0.5, 0.5)
GodButton.BackgroundColor3 = Color3.fromRGB(255, 234, 0)
GodButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
GodButton.BorderSizePixel = 0
GodButton.Position = UDim2.new(0.759312153, 0, 0.899216473, 0)
GodButton.Size = UDim2.new(0.426999986, 0, 0.128000006, 0)
GodButton.Font = Enum.Font.SourceSansBold
GodButton.Text = "GOD"
GodButton.TextColor3 = Color3.fromRGB(255, 255, 255)
GodButton.TextScaled = true
GodButton.TextSize = 14.000
GodButton.TextWrapped = true

UICorner_5.Parent = GodButton

TPButton.Name = "TPButton"
TPButton.Parent = MainFrame
TPButton.AnchorPoint = Vector2.new(0.5, 0.5)
TPButton.BackgroundColor3 = Color3.fromRGB(89, 255, 0)
TPButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
TPButton.BorderSizePixel = 0
TPButton.Position = UDim2.new(0.498895764, 0, 1.09864616, 0)
TPButton.Size = UDim2.new(0.426567137, 0, 0.1277778, 0)
TPButton.Font = Enum.Font.SourceSansBold
TPButton.Text = "TP PR"
TPButton.TextColor3 = Color3.fromRGB(255, 255, 255)
TPButton.TextScaled = true
TPButton.TextSize = 14.000
TPButton.TextWrapped = true

UICorner_6.Parent = TPButton

-- Scripts:

local function LEEPK_fake_script() -- MainFrame.Handler 
	local script = Instance.new('LocalScript', MainFrame)

	--[[
		Script improved by Gemini.
		- Allows selection via GUI list or by clicking the character in-world.
		- Uses events (PlayerAdded/PlayerRemoving) to manage the player list efficiently.
		- Eliminates unnecessary while/repeat loops to reduce client-side load.
		- Centralizes GUI update logic to run only when changes occur.
		- Prevents memory leaks by properly disconnecting signals.
		- Integrated "God Ritual" functionality with its own button and state.
		- Kill and God actions are mutually exclusive and can be cancelled.
	]]
	
	--// Services and Variables
	local Players = game:GetService("Players")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local RunService = game:GetService("RunService")
	local Debris = game:GetService("Debris")
	
	local LocalPlayer = Players.LocalPlayer
	local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
	local Mouse = LocalPlayer:GetMouse()
	
	--// Remotes
	local Remotes = {
		Attack = ReplicatedStorage:WaitForChild("AttackHandlerRemoteEvent"),
		PounceAttack = ReplicatedStorage:WaitForChild("SpecialAttackRemoteEvent_PounceAttack"),
		ChargedAttack = ReplicatedStorage:WaitForChild("SpecialAttackRemoteEvent_ChargedAttack"), -- Added for God Ritual
		Ragdoll = ReplicatedStorage:WaitForChild("TrampleDamageHandlerRemoteEvent"),
		Respawn = ReplicatedStorage:WaitForChild("SpawnAsCharacterRemoteFunction"),
		ReplicateEffects = ReplicatedStorage:WaitForChild("ReplicateEffectsRemoteEvent"),
		AntiLatch = ReplicatedStorage:WaitForChild("LatchedPlayersNotifyRemoteEvent")
	}
	
	--// GUI
	local Gui = PlayerGui:WaitForChild("SL")
	local MainFrame = Gui:WaitForChild("MainFrame")
	local Container = MainFrame.Container
	local Template = MainFrame.Template
	local KillButton = MainFrame.KillButton
	local GodButton = MainFrame.GodButton
	local TPButton = MainFrame.TPButton
	local SelectedLabel = MainFrame.Selected
	
	local LatchGui = Players.LocalPlayer.PlayerGui.ExitLatchScreenGui
	
	--// Constants and State
	local HEALTH_RESPAWN_THRESHOLD = 80
	local ATTACK_INTERVAL = 0.05
	
	local COLORS = {
		DEFAULT_TEMPLATE = Template.BackgroundColor3,
		DEFAULT_BUTTON = KillButton.BackgroundColor3,
		SELECTED_PLAYER = Color3.new(0.184314, 1, 0),
		CANCEL_BUTTON = Color3.new(1, 0, 0.0156863)
	}
	
	local playerConnections = {}
	local selectedPlayer = nil
	local isAttacking = false
	local isGodding = false -- New state for the ritual
	
	--// Functions
	
	function missing(t, f, fallback)
		if type(f) == t then return f end
		return fallback
	end
	
	cloneref = missing("function", cloneref, function(...) return ... end)
	
	-- Gets the local player's character display name
	function getCharacterDisplayName()
		local character = LocalPlayer.Character
		local head = character and character:FindFirstChild("Head")
		local nameGui = head and head:FindFirstChild("CharacterNameBillboardGui")
		local textLabel = nameGui and nameGui:FindFirstChild("TextLabel")
		return textLabel and textLabel.Text
	end
	
	-- Invokes the player's respawn
	function respawnPlayer()
		local displayName = getCharacterDisplayName()
		if not displayName then
			warn("Could not get DisplayName to respawn.")
			return
		end
		print("Respawning...")
		Remotes.Respawn:InvokeServer(displayName)
	end
	
	-- Updates the visual state of all action buttons
	function updateAllButtonVisuals()
		-- Kill Button
		if isAttacking then
			KillButton.BackgroundColor3 = COLORS.CANCEL_BUTTON
			KillButton.Text = "CANCEL"
		else
			KillButton.BackgroundColor3 = COLORS.DEFAULT_BUTTON
			KillButton.Text = "KILL"
		end
	
		-- God Button
		if isGodding then
			GodButton.BackgroundColor3 = COLORS.CANCEL_BUTTON
			GodButton.Text = "CANCEL"
		else
			GodButton.BackgroundColor3 = COLORS.DEFAULT_BUTTON
			GodButton.Text = "GOD"
		end
	end
	
	-- Updates the selection visuals (background color and label text)
	function updateSelectionVisuals()
		if selectedPlayer and selectedPlayer.Parent then
			SelectedLabel.Text = selectedPlayer.Name .. " (" .. selectedPlayer.DisplayName .. ")"
		else
			SelectedLabel.Text = "No player selected"
			selectedPlayer = nil
		end
	
		for _, frame in ipairs(Container:GetChildren()) do
			if frame:IsA("Frame") and frame.Name ~= "Template" then
				if selectedPlayer and frame.Name == selectedPlayer.Name then
					frame.BackgroundColor3 = COLORS.SELECTED_PLAYER
				else
					frame.BackgroundColor3 = COLORS.DEFAULT_TEMPLATE
				end
			end
		end
	end
	
	-- Adds a player frame to the list
	function addPlayerFrame(player)
		if player == LocalPlayer then return end
	
		local newFrame = Template:Clone()
		newFrame.Name = player.Name
		newFrame.InnerFrame.PlayerName.Text = player.Name .. " (" .. player.DisplayName .. ")"
		newFrame.LayoutOrder = string.byte(string.upper(string.sub(player.Name, 1, 1)))
		newFrame.Visible = true
		newFrame.Parent = Container
	
		playerConnections[player] = newFrame.InnerFrame.TextButton.MouseButton1Click:Connect(function()
			selectedPlayer = player
			updateSelectionVisuals()
		end)
	end
	
	-- Removes a player frame from the list
	function removePlayerFrame(player)
		if playerConnections[player] then
			playerConnections[player]:Disconnect()
			playerConnections[player] = nil
		end
	
		local frame = Container:FindFirstChild(player.Name)
		if frame then
			frame:Destroy()
		end
	
		if selectedPlayer == player then
			selectedPlayer = nil
			updateSelectionVisuals()
		end
	end
	
	-- Checks if the conditions to continue the attack are met
	function checkAttackConditions()
		local localChar = LocalPlayer.Character
		if not (selectedPlayer and selectedPlayer.Parent and localChar) then return false end
	
		local targetChar = selectedPlayer.Character
		if not (targetChar and targetChar.Parent == workspace) then return false end
	
		local targetHum = targetChar:FindFirstChildOfClass("Humanoid")
		if not (targetHum and targetHum.Health > 0) then return false end
	
		return true
	end
	
	-- The main attack loop
	function executeAttackLoop()
		task.spawn(function()
			while isAttacking and checkAttackConditions() do
				local localChar = LocalPlayer.Character
				local targetChar = selectedPlayer.Character
				pcall(function()
					localChar.Head.CFrame = CFrame.new(targetChar.PrimaryPart.Position)
				end)
				task.wait()
			end
		end)
		while isAttacking and checkAttackConditions() do
			local localChar = LocalPlayer.Character
			local targetChar = selectedPlayer.Character
			local targetHum = targetChar and targetChar:FindFirstChildOfClass("Humanoid")
			local ragdollPart = targetChar and targetChar:FindFirstChild("RagdollColliderParts") and targetChar.RagdollColliderParts:FindFirstChildWhichIsA("BasePart")
	
			local localHum = localChar:FindFirstChildOfClass("Humanoid")
			if localHum and localHum.Health < localHum.MaxHealth * (HEALTH_RESPAWN_THRESHOLD / 100) then
				respawnPlayer()
				task.wait(0.2)
			end
	
			if not (targetHum and ragdollPart) then break end
	
			pcall(Remotes.PounceAttack.FireServer, Remotes.PounceAttack, targetHum, ragdollPart)
			task.wait(ATTACK_INTERVAL)
			pcall(Remotes.PounceAttack.FireServer, Remotes.PounceAttack, targetHum, ragdollPart)
			task.wait(ATTACK_INTERVAL)
			pcall(Remotes.PounceAttack.FireServer, Remotes.PounceAttack, targetHum, ragdollPart)
	
			pcall(Remotes.Ragdoll.FireServer, Remotes.Ragdoll, targetHum, ragdollPart)
			pcall(Remotes.Attack.FireServer, Remotes.Attack, targetHum)
	
			task.wait()
		end
		task.spawn(function()
			for i=0,10 do
				Remotes.PounceAttack:FireServer("Cancel")
				task.wait()
			end
		end)
		isAttacking = false
		updateAllButtonVisuals()
		print("Attack has finished.")
	end
	
	--// GOD RITUAL FUNCTIONS (Integrated)
	
	-- Helper to send an emote at a specific world position
	function sendEmoteAtPosition(position, animalType, animalName, emoteName)
		local attachment = Instance.new("Attachment")
		attachment.WorldPosition = position
		attachment.Parent = workspace.Terrain
	
		Remotes.ReplicateEffects:FireServer(
			"EmoteSound",
			position,
			{
				AnimalType = animalType,
				AnimalName = animalName,
				AnimalAge = "Adult",
				PartRef = attachment,
				EmoteName = emoteName,
				PlayerName = LocalPlayer.Name
			}
		)
	
		Debris:AddItem(attachment, 2)
	end
	
	-- The main god ritual function
	function godPlayer(victim)
		if not (victim and victim:IsDescendantOf(Players)) then 
			isGodding = false
			updateAllButtonVisuals()
			return 
		end
	
		local localChar = LocalPlayer.Character
		local victimChar = victim.Character
	
		if not (localChar and victimChar) then
			isGodding = false
			updateAllButtonVisuals()
			return
		end
	
		local localRoot = localChar.PrimaryPart
		local victimRoot = victimChar.PrimaryPart
	
		if not (localRoot and victimRoot) then
			isGodding = false
			updateAllButtonVisuals()
			return
		end
	
		local distance = (localRoot.Position - victimRoot.Position).Magnitude
		if distance > 100 then
			print("Too far from victim!")
			isGodding = false
			updateAllButtonVisuals()
			return
		end
	
		local radius, height, speed, duration = 20, 1, 3, 10
		local angle = 0
		local startTime = tick()
		local finished = Instance.new("BindableEvent")
		local connection
	
		-- Sound effect loop in a separate thread
		local finishSoundLoop = false
		task.spawn(function()
			while not finishSoundLoop and isGodding do
				-- Original sounds
				pcall(Remotes.ReplicateEffects.FireServer, Remotes.ReplicateEffects, "SpecialAttackSound", localRoot.Position, {
					AnimalType = "Reptiles", AnimalName = "Croc", AnimalAge = "Adult", PartRef = localChar:WaitForChild("Head")
				})
				pcall(Remotes.ReplicateEffects.FireServer, Remotes.ReplicateEffects, "SpecialAttackSound", victimRoot.Position, {
					AnimalType = "Mammals", AnimalName = "Elephant", AnimalAge = "Adult", PartRef = victimRoot
				})
	
				-- Random hyena laughs
				local randomAngle = math.random() * math.pi * 2
				local laughRadius = math.random(25, 40)
				local pos = victimRoot.Position + Vector3.new(math.cos(randomAngle) * laughRadius, 2, math.sin(randomAngle) * laughRadius)
				sendEmoteAtPosition(pos, "Mammals", "Hyena", "Laugh")
	
				task.wait(0.1)
			end
		end)
	
		-- Orbiting loop
		connection = RunService.RenderStepped:Connect(function(dt)
			if not isGodding or tick() - startTime > duration or not victimRoot.Parent or not localRoot.Parent then
				connection:Disconnect()
				finished:Fire()
				return
			end
	
			angle += speed * dt
			local offset = Vector3.new(math.cos(angle) * radius, height, math.sin(angle) * radius)
			localRoot.CFrame = CFrame.new(victimRoot.Position + offset, victimRoot.Position)
		end)
	
		finished.Event:Wait() -- Wait until orbit is done or cancelled
		finishSoundLoop = true
	
		-- Only do the final attack if the ritual wasn't cancelled
		if isGodding and victimChar and victimChar:FindFirstChildOfClass("Humanoid") then
			localRoot.CFrame = CFrame.new(victimRoot.Position)
			Remotes.ChargedAttack:FireServer(victimChar.Humanoid, 0/0)
	
			task.spawn(function()
				for i = 1, 100 do
					if not isGodding then break end
					Remotes.ReplicateEffects:FireServer("EmoteSound", victimRoot.Position, {
						AnimalType = "Mammals", AnimalName = "Elephant", AnimalAge = "Adult",
						PartRef = victimRoot, EmoteName = "LongTrumpet", PlayerName = LocalPlayer.Name
					})
					task.wait()
				end
			end)
		end
	
		isGodding = false
		updateAllButtonVisuals()
		print("God ritual has finished.")
	end
	
	-- Handles clicks on characters in the workspace
	function handleCharacterClick()
		local target = Mouse.Target
		if not target or not target.Parent then return end
	
		local character = target:FindFirstAncestorOfClass("Model")
		if not character or not character:FindFirstChildOfClass("Humanoid") then return end
	
		local player = Players:GetPlayerFromCharacter(character)
	
		if player and playerConnections[player] then
			selectedPlayer = player
			updateSelectionVisuals()
			print("Selected " .. player.Name .. " by clicking their character.")
		end
	end
	
	function antiAfk()
		local GC = getconnections or get_signal_cons
		if GC then
			for i,v in pairs(GC(Players.LocalPlayer.Idled)) do
				if v["Disable"] then v["Disable"](v) elseif v["Disconnect"] then v["Disconnect"](v) end
			end
		else
			local VirtualUser = cloneref(game:GetService("VirtualUser"))
			Players.LocalPlayer.Idled:Connect(function()
				VirtualUser:CaptureController()
				VirtualUser:ClickButton2(Vector2.new())
			end)
		end
	end
	
	--// Event Connections and Initialization
	
	-- Main attack button
	KillButton.MouseButton1Click:Connect(function()
		if isAttacking then
			isAttacking = false -- Cancel current attack
			print("Attack cancelled.")
		elseif isGodding then
			warn("Cannot start attack, God Ritual is in progress.")
		elseif selectedPlayer then
			isAttacking = true
			task.spawn(executeAttackLoop)
		else
			warn("Attempted to attack without a selected target.")
		end
		updateAllButtonVisuals()
	end)
	
	LatchGui.Changed:Connect(function()
		repeat
			for i=0,5 do
				task.spawn(function()
					Remotes.AntiLatch:FireServer()
				end)
			end
			task.wait()
		until LatchGui.Enabled == false
	end)
	
	-- God ritual button
	GodButton.MouseButton1Click:Connect(function()
		if isGodding then
			isGodding = false -- Cancel current ritual
			print("God ritual cancelled.")
		elseif isAttacking then
			warn("Cannot start God Ritual, attack is in progress.")
		elseif selectedPlayer then
			isGodding = true
			task.spawn(godPlayer, selectedPlayer) -- Pass selectedPlayer as the victim
		else
			warn("Attempted to start God Ritual without a selected target.")
		end
		updateAllButtonVisuals()
	end)
	
	TPButton.MouseButton1Click:Connect(function()
		task.spawn(function()
			loadstring(game:HttpGet('https://raw.githubusercontent.com/C0dexDev/rbxexp/refs/heads/main/TPPR3'))()
		end)
	end)
	-- Connect the character click handler
	Mouse.Button1Down:Connect(handleCharacterClick)
	
	-- Player list management
	Players.PlayerAdded:Connect(addPlayerFrame)
	Players.PlayerRemoving:Connect(removePlayerFrame)
	
	-- Deselection handler
	RunService.Heartbeat:Connect(function()
		if selectedPlayer then
			local char = selectedPlayer.Character
			local hum = char and char:FindFirstChildOfClass("Humanoid")
			if not hum or hum.Health <= 0 then
				selectedPlayer = nil
				updateSelectionVisuals()
			end
		end
	end)
	
	-- Initialization
	for _, player in ipairs(Players:GetPlayers()) do
		addPlayerFrame(player)
	end
	
	antiAfk()
	updateAllButtonVisuals()
	updateSelectionVisuals()
	print("Selection and attack system initialized.")
	
	task.spawn(function()
		while task.wait() do
			pcall(function()
				ReplicatedStorage:WaitForChild("PlayerDamageSelfRemoteEvent"):FireServer(0/0)
				if workspace:FindFirstChild("MapAssets") then
					workspace.MapAssets:Destroy()
				end
				if workspace:FindFirstChild("MainWaterPart") then
					workspace.MainWaterPart:Destroy()
				end
			end)
		end
	end)
end
coroutine.wrap(LEEPK_fake_script)()
local function PJKZCL_fake_script() -- MainFrame.Drag 
	local script = Instance.new('LocalScript', MainFrame)

	local UserInputService = game:GetService("UserInputService")
	
	local frame = script.Parent
	local dragging = false
	local dragStart
	local startPos
	
	local function update(input)
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end
	
	frame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = frame.Position
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	frame.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			if dragging then
				update(input)
			end
		end
	end)
	
end
coroutine.wrap(PJKZCL_fake_script)()
